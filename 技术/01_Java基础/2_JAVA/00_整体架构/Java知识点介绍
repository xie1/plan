www

整理Java_QS：
第一阶段java基础：
00、Java虚拟机：
		Java 语言的编译、运行、类加载机制，类文件结构、内存的分配策略、垃圾回收机制、javac 编译、JIT 编译等 JVM 相关知识
				01、JVM 是 Java 的核心和基础，在 Java 编译器和 os 平台之间的虚拟处理器。它是一种基于下层的操作系统和硬件平台并利用软件方法来实现的抽象的计算机，可以在上面执行 Java 的字节码程序。
				Java 编译器只需面向 JVM，生成 JVM 能理解的代码或字节码文件。Java 源文件经编译器，编译成字节码程序，通过 JVM 将每一条指令翻译成不同平台机器码，通过特定平台运行。
				简单的说，JVM 就相当于一台柴油机,它只能用 Java (柴油)运行,JVM 就是 Java 的虚拟机,有了 JVM 才能运行 Java 程序

				02、Java 代码编译和执行的整个过程包含了以下三个重要的机制：
						01、Java 源码编译由以下三个过程组成：
							分析和输入到符号表
							注解处理
							语义分析和生成 class 文件
						02、类加载机制：JVM 的类加载是通过 ClassLoader 及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：
								01、类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段
								02、类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定（也成为动态绑定或晚期绑定）
								03、绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对 Java 来说，绑定分为静态绑定和动态绑定
										01、动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在 Java 中，几乎所有的方法都是后期绑定的
										02、静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对 Java，简单的可以理解为程序编译期的绑定。Java 当中的方法只有 final，static，private 和构造方法是前期绑定的
						03、类执行机制
						
				03、类初始化
				类初始化是类加载过程的最后一个阶段，到初始化阶段，才真正开始执行类中的 Java 程序代码。虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：
				遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的 Java 代码场景是：
				使用 new 关键字实例化对象时、读取或设置一个类的静态字段（static）时（被 static 修饰又被 final 修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。
				使用 Java.lang.refect 包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。
				当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
				当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。
				虚拟机规定只有这四种情况才会触发类的初始化，称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发其初始化，称为被动引用。下面举一些例子来说明被动引用。
				
				04、多态性实现机制——静态分派与动态分派：目前的 Java 语言（JDK1.6）是一门静态多分派、动态单分派的语言
				05、垃圾回收机制：Java 中的垃圾回收一般是在 Java 堆中进行，因为堆中几乎存放了 Java 中所有的对象实例




01、Java开发介绍
		01、Java的发展历史
		02、Java的应用领域
		03、Java语言的特性
		04、Java面向对象
		05、Java性能分类
		06、搭建Java环境
		07、Java工作原理
02、熟悉Eclipse开发工具
03、Java语言基础
		01、Java主类结构
				01、基本概念：
						对象:对象具有状态和行为。例如：狗有它的状态—颜色，名字，品种，同时也有行为—摇尾巴，汪汪叫，吃东西。对象时类的一个实例。
						类:类可以被定义为描述对象所支持的类型的行为和状态的模板或蓝图。
						方法:方法是一种基本的行为。类中可以包含很多方法。在方法中，可以编写逻辑，操纵数据，执行动作。
						实体变量:每个对象都有它的特殊的实体变量的集合，一个对象的状态是由那些实体变量所被赋的值所决定的。
						
				02、基本语法
						大小写敏感性： Java 是一种大小写敏感的语言，这就意味着 Hello 和 hello 在 Java 中代表不同的意思。
						类的命名：所有类的名称首字母必须大写。
						如果类名称中包含几个单词，那么每个单词的首字母都要大写。
						例如类 MyFirstJavaClass
						方法的命名：所有方法名称必须以小写字母开头。
						如果方法名称中包含几个单词，那么其中的每个单词的首字母都要大写。
						例如 public void myMethodName()
						程序文件名：程序的文件名必须和类的名称准确匹配。
						但保存文件时，你应当以类的名称保存（注意区分大小写），并在文件名后加 .java 的后缀（如果文件名和类名不匹配那么将无法编译你的程序）。
						例如：假设类名是 MyFirstJavaProgram，那么文件名就应该是 MyFirstJavaProgram.java。
						public static void main(String args[])：Java 程序都是从 main（） 方法开始处理的，这个方法是 Java 程序的强制性的部分。
						
						Java 标识符
						Java 的所有的组成部分都要有自己的名称。类、变量和方法的名称称为标识符。
						在 Java 中，需要记住关于标识符的一下几点。如下：
						所有标识符必须以字母（ A 到 Z 或者 a 到 z ）、货币字符（ $ ）或者下划线( _ )开头。
						在第一个标识符之后可以有任意字母组合。
						关键字不能被用作标识符。
						大多数标识符需要区分大小写。
						合法标识符的例子： age, $salary, _value, __1_value
						非法标识符的例子： 123abc, -salary
						
						Java 修饰符
						如其语言一样，方法和类等等是可以通过修饰符修饰的。Java 中有两种修饰符：
						访问修饰符：default, public , protected, private
						非访问修饰符：final, abstract, strictfp
						我们将在下一节继续学习修饰符相关知识。

						Java 变量
						在 Java 中我们可以看到如下变量：
						本地变量
						类变量（静态变量）
						实例变量（非静态变量）
						
						Java 数组
						数组时储存有多重相同变量类型的对象。然而，数字自身也是堆中的一个对象。我们将要学习如何声明，建立，初始化数组。

						Java 枚举值
						枚举是在 Java5.0 版本中被引进的。枚举限制了变量要有一些预先定义的值。枚举列表中的值称为枚举值。
						
						03、可访问描述符
						Java 提供一系列可访问描述符来设定类，变量，方法和构造器的访问级别。四种访问级别如下：
						默认的，对封装可见。不需要描述符。
						仅对类可见（private）
						全部可见（public）
						对封装和子类可见（protected）
						不可访问描述符
						Java 提供一些不可访问描述符来满足其他功能。
						Static 描述符是用来创造类方法和变量的。
						Final 描述符用来最终确定和实施类、方法和变量的。
						Abstract 描述符用来创造不允许实例化的类和方法。
						synchronized 和 volatile 描述符用来当做线的。
		02、Java变量与常量
				01、3种类型变量
						本地变量
						实例变量
						静态变量
		03、Java基本数据类型
				01、原始数据类型/引用数据类型
				02、字节型（byte）
				字节型是一种 8 位有正负的二进制整数
				最小值是 -128(-2^7)
				最大值是 127(2^7-1)
				默认值为 0
				字节型数据类型主要是为了在大型数组内节省空间，主要是替代整数由于字节型比整数小 4 倍。
				例如：byte a = 100 , byte b = -50
				短整数（short）

				短整数是一种 16 位有正负的二进制整数
				最小值是 -32768(-2^15)
				最大值是 32767(2^15-1)
				短整数类型的数据也可以像字节型一样用于节省空间。短整数比整数小两倍
				默认值为 0
				例如：short s = 10000, short r = -20000
				整数型（int）

				整数型是一种 32 位有正负的二进制整数
				最小值是 - 2,147,483,648(-2^31)
				最大值是 2,147,483,647(2^31 -1)
				整数型一般默认被应用于整数值除非担心内存不够用。
				默认值为 0
				例如：int a = 100000, int b = -200000
				长整型（long）

				长整型是一种 64 位有正负的二进制整数
				最小值是 -9,223,372,036,854,775,808(-2^63)
				最大值是 9,223,372,036,854,775,807 (2^63 -1)
				这种数据类型一般是在需要比整数型范围更大时应用。
				默认值为 0L
				例如：long a = 100000L, int b = -200000L
				浮点型（float）

				浮点型数据是一种单精度的 32 位 IEEE 754 标准下的浮点数据。
				浮点型数据主要是为了在大型浮点数字数组中节约内存。
				默认值是 0.0f。
				浮点型数据不能用于如货币这样的精确数据。
				例如：float f1 = 234.5f
				双精度型（double）

				双精度型数据是一种双精度的 64 位 IEEE 754 标准下的浮点数据。
				这种数据类型主要是默认被用于表示小数的值，一般是默认的选择。
				双精度型数据不能用于如货币这样的精确数据。
				默认值是 0.0d
				例如：double d1 = 123.4
				布尔型（boolean）

				布尔型数据代表一个信息比特。
				它只有两个可能的值：真（true）和假（false）
				这种数据类型用于真假条件下的简单标记。
				默认值是假（false）
				例如：boolean one = true
				字符型（char）

				字符型数据是简单的 16 位 Unicode 标准下的字符。
				最小值是： '\u0000' (或 0)。
				最大值是： '\uffff' (或 65,535 )。
				字符型数据可以用来储存任意字母。
				例如： char letter A（字符型的字母A） ='A'
				
				
				引用数据类型
				引用数据类型是由类的编辑器定义的。他们是用于访问对象的。这些变量被定义为不可更改的特定类型。例如：Employee， Puppy 等等。
				类对象和数组变量就是这种引用数据类型。
				任何引用数据类型的默认值都为空。
				一个引用数据类型可以被用于任何声明类型和兼容类型的对象。
				例如：Animal animal = new Animal("giraffe")；
		04、Java运算符
				01、分类：
				算数运算符
				关系运算符
				位运算符
				逻辑运算符
				赋值运算符
				其他运算符
		05、数据类型转换
		06、代码类型与编码规范
		07、Java帮助文档
04、Java流程控制
		01、复合语句
		02、if条件语句
		03、条件语句
		04、swith多分支语句
				01、规则：
						在 switch 语句中使用的变量只能是一个字节，short，int 或 char。
						在一个 switch 语句中可以有任何数量的 case 语句。每个 case 后跟着即将被比较的值和一个冒号。
						对于 case 的值必须是相同的数据类型作为开关变量，它必须是一个常量或文字。
						当被启动了的变量与 case 是相等的，那 case 后的语句将执行，一直到 break 为止。
						当达到一个 break 语句，switch 终止，并且控制流跳转到跟着 switch 语句的下一行。
						不是每一个 case 需要包含一个 break。如果没有出现 break，控制流将贯穿到后面的 case 直到 break 为止。
switch 语句可以有一个可选默认 case ，它必须出现在 switch 的结束处。在执行一项任务时没有任何 case 是真，那默认 case 可被使用。在默认 case 中不需要 break
		05、while语句
		06、do...while语句
		07、for循环语句
05、Java字符串
		01、String类
		02、连接字符串
		03、获取字符串信息
		04、字符串操作
		05、格式化字符串
		06、使用正则表达式
		07、字符串生成器
				01、java正则表达式：
						java.util.regex 包主要包含了下面的三个类：
						Pattern 类:一个 Pattern 对象是正则表达式编译表示。 Pattern 类没有提供公共的构造函数。要创建一个 Pattern 对象，
						你必须首先调用他的公用静态编译方法来获得 Pattern 对象。这些方法的第一个参数是正则表达式。
						Matcher 类:一个 Matcher 对象是用来解释模式和执行与输入字符串相匹配的操作。和 Pattern 类一样 Matcher 类也是没有构造方法的，
						你需要通过调用 Pattern 对象的 matcher 方法来获得 Matcher 对象。
						PatternSyntaxException: 一个 PatternSyntaxException 对象是一个不被检查的异常，来指示正则表达式中的语法错误
06、Java数组
		01、数组概述
		02、二维数组的创建及使用
		03、一维数组的创建及使用
		04、数组基本操作
		05、数组排序算法
		06、数组的引用传递
		07、多维数组介绍
07、类的基本概念
		01、类的定义与设计
		02、类的封装与访问控制
		03、对象的创建与应用
		04、构造方法与this关键字
		05、静态变量与静态方法
		06、内部类与对象数组
08、继承与多态
		01、继承的概念
				01、方法重写规则
						重写方法的参数列表应该与原方法完全相同。
						返回值类型应该和原方法的返回值类型一样或者是它在父类定义时的子类型。
						重写函数访问级别限制不能比原函数高。举个例子：如果父类方法声明为公有的，那么子类中的重写方法不能是私有的或是保护的。
						只有被子类继承时，方法才能被重写。
						方法定义为 final，将导致不能被重写。
						一个方法被定义为 static，将使其不能被重写，但是可以重新声明。
						一个方法不能被继承，那么也不能被重写。
						和父类在一个包中的子类能够重写任何没有被声明为 private 和 final 的父类方法。
						和父类不在同一个包中的子类只能重写 non-final 方法或被声明为 public 或 protected 的方法。
						一个重写方法能够抛出任何运行时异常，不管被重写方法是否抛出异常。然而重写方法不应该抛出比被重写方法声明的更新更广泛的已检查异常。重写方法能够抛出比被重写方法更窄或更少的异常。
						构造函数不能重写
		02、抽象类与接口
				01、使用关键字 abstract 来声明一个抽象类。它出现在关键字 class 的前面
						声明一个抽象方法有两个结果:如果一个类中含有一个抽象方法，类必须也是抽象的。
						任何一个子类必须覆盖这个抽象方法，或者继续将它声明为抽象方法。
		03、final与super关键字
				01、当调用父类的被重写的方法时，要用关键字 super
		04、接口实现多继承
				01、接口是抽象方法的集合。如果一个类实现了一个接口，那么就需要继承这个接口中的所有抽象方法。
						接口不是类。写一个接口和写一个类很相似，但是它们是两个不同的概念。类是描述一个对象的成员属性和行为。接口只包含一个类所实现的行为。
						除非实现了接口的类是抽象的,否则接口中的所有方法都需要在类中实现。在以下方面，接口和类非常相似：
						一个接口可以包含任意数量的方法。
						一个接口以 .java 的扩展名写入文件中，并且接口的名字与文件名相同。
						接口的字节码位于一个 .class 文件中。
						接口位于包中，并且相应的字节码文件必须在和该包名匹配的文件夹结构下。
						然而,在以下方面,接口和类是不同的:
						不能实例化一个接口。
						接口不能包含构造方法。
						接口中的所有方法都是抽象的。
						接口不能包含实例变量。接口中唯一能出现的变量必须被同时声明为 static 和 final 。
						接口不能被类继承；它应该被类实现。
		05、对象类型转换
		06、匿名内部类
				01、1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
						2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
						3、创建内部类对象的时刻并不依赖于外围类对象的创建。
						4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
						5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。
		07、接口与继承
		08、多态性
				01、引用变量是唯一可以用来访问一个对象的方法。引用变量可以只有一个类型。引用变量一旦被声明是不能被改变的。
					 引用变量能够重新分配到其他提供的没有被声明为 final 的对象。引用变量的类型将决定它可以调用的对象的方法。
					 一个引用变量能够引用任何一个对象的声明类型或任何声明类型的子类型。一个引用变量可以声明为一个类或接口类型。
		09、Java 泛型
				01、泛型方法的规则：
						所有的泛型方法声明在方法的返回值之前(下一个例子中的)有一个由尖括号分隔开的类型参数区域。()
						类型参数能被用来声明返回类型和作为传给泛型方法的参数类型的占位符，就是为人所知的真正的类型参数。
						一个泛型方法的主体像其他方法声明一样。注意到类型参数仅能代表引用类型，而不是原始类型(就像 int,double 和 char)
						 public static < E > void printArray( E[] inputArray )
						   {           
						         for ( E element : inputArray ){        
						            System.out.printf( "%s ", element );
						         }
						         System.out.println();
						    }
		10、Java 网络编程（重点理解）
				01、java.net 包为两种常用的网络协议提供支持：
						TCP： TCP 代表传输控制协议，允许两个应用程序间的可靠通信。TCP 通常在因特网协议上被使用，这被称为 TCP/IP。
						UDP： UDP 代表用户数据报协议，一个无连接的允许应用程序间数据包传输的协议。
						本教程给以下两个主题提供更好的理解：

						套接字编程： 这是在网络中最广泛使用的概念并且被很详细地解释。
						URL 处理： 这将被个别地解释。点击这里来学习 java 语言中的 URL 处理。
						套接字编程
						套接字利用TCP在两台电脑间提供通信机制。一个客户端程序在通信最后创建一个套接字并努力连接服务器套接字。

						当连接建立时，服务器在通信结束时创建一个套接字对象。客户端和服务器现在可以通过从套接字读或者写来交流。

						java.net.Socket 类代表一个套接字，而且 java.net.ServerSocket 类为服务器程序提供了一种机制来监听客户端并和它们建立连接。

						以下步骤发生在两台电脑使用套接字建立TCP连接时：

						服务器实例化一个 ServerSocket 对象，指示通信将产生在哪个端口号；
						服务器调用 ServerSocket 类的 accept() 方法。这个方法等待直到一个客户端在给定的端口上连接到服务器；
						在服务器等待后，一个客户端实例化一个 Socket 对象，指定服务器名称和连接的端口号；
						Socket 类的构造函数努力将客户端连接到指定的服务器和端口号。如果通信建立，客户端现在就拥有了一个能和服务器通信的 Socket 对象；
						在服务器端，accept() 方法在服务器上返回一个连接到客户端套接字的新的套接字。
						在连接建立后，通信可以使用 I/O 流产生。每个套接字都有一个输出流和一个输入流。客户端的输出流连接到服务器端的输入流，客户端的输入流连接到服务器端的输出流					
09、I/O与反射、多线程
		01、流概述与File类
				01、字节流：Java 字节流是用来处理8比特字节的输入和输出。尽管有许多的有关字节流的类，但是最常用的是 FileInputStream 类和 FileOutputStream类
				02、字符流：Java 字节流是用来处理8比特字节的输入和输出，Java 字符流用于处理16位 unicode 的输入和输出。尽管这里有许多关于字符流的类，但最常用的类是， FileReader 和 FileWriter。
				虽然在内部 FileReader 还是使用 FileInputStream 和 FileWriter 使用 FileOutputStream，但是主要的区别是 FileReader 和 FileWriter 一次读写两个字节。
		02、Annotation功能类型信息
		03、文件 输入/输出流
		04、缓存 输入/输出流
		05、Class类与反射
		06、枚举类型与泛型
		07、创建、操作线程与线程安全
				01、线程的生命周期：一个线程生成，开始，运行，然后死亡
						new： 一个新的线程以一个新的状态开始了它的生命周期。它始终留在这个状态中直到程序开始线程。它也被称为一个生成的进程。
						Runnable： 在一个新生成的线程开始后，这个线程变得可运行。在这个状态下的线程被认为正在执行任务。
						Waiting： 有时候，一个线程当它等待另一个线程工作时跃迁到等待状态。一个线程仅当另一个线程发信号给等待的线程继续执行才跃迁回可运行转态。
						Timed waiting： 一个可运行的线程能进入定时等待状态等待指定的时间间隔。在这种转态下的线程当时间间隔死亡或者当它所等待的活动发生时跃迁回可运行状态。
						Terminated： 一个可运行的线程，当它完成了它的任务后进入 terminated 状态，否则它就结束。

						02、实现方法：
						通过实现 Runnable 接口创建线程
						如果你的类想要作为一个线程被执行，那么你可以通过实现 Runnable 接口来到达这个目的。你将需要遵从三个基本步骤：
						步骤一：
						作为第一步你需要实现由 Runnable 接口提供的 run() 方法。这个方法为线程提供了进入点并且你将把你完全的业务逻辑放入方法中。下列是简单的 run() 方法语法：
						public void run( )
						步骤二：
						在第二步你将使用以下的构造函数实例化一个 Thread 对象:
						Thread(Runnable threadObj, String threadName);
						threadObj 是实现 Runnable 接口的类的一个实例，threadName 是给新线程的名字。
						步骤三：
						一旦 Thread 对象被创建，你可以通过调用 run() 方法的 start() 方法来开始它。以下是 start() 方法的简单语法：
						void start( );

						通过继承 Thread 类来创建线程
						第二个创建线程的方法是创建一个通过使用以下两个简单步骤继承 Thread 类的新的类。这个方法在解决 Thread 类中使用可行方法创建的多线程的问题上提供了更多的灵活性。
						步骤一：
						你将需要覆写 Thread 类中可用的 run()方法。这个方法为线程提供入口并且你将把你完全的业务逻辑放入方法中。以下是 run()方法的简单的语法。
						public void run( )
						步骤二：
						一旦 Thread 对象被创建，你可以通过调用 run()方法的 start() 方法来开始它。以下是 start() 方法的简单语法：
						void start( );

第三阶段JSP和数据库：
		01、数据库
				01、Mysql数据库安装与使用
				02、MongoDB和Reids介绍
				03、JDBC
				04、连接池和DBUtils
				05、Oracle介绍与实战
				06、apache服务器/Nginx服务器
				07、Memcached内存对象
		02、JavaWeb开发核心
				01、XML
				02、Servlet工作原理解析
				03、HTTP协议
				04、深入理解Session与Cookie
				05、Tomcat的系统架构与设计模式
				06、JSP语法与内置对象
				07、JDBC技术
				08、大浏览量系统的静态化架构设计
		03、JavaWeb开发内幕
				01、深入理解Web请求过程
				02、Java I/O的工作机制
				03、Java Web中文编码
				04、Javac编译原理
				05、class文件结构
				06、ClassLoader工作机制
				07、JVM体系结构与工作方式
				08、JVM内存管理
第四阶段JavaEE：
		01、Struts2框架
				01、MVC思想概述
				02、Struts 2的下载和安装
				03、Struts 2的流程
				04、Struts 2的国际化
				05、Struts 2的标签库
				06、Struts 2的类型转换与输入校验
				07、使用Struts 2控件文件上传与下载
				08、详解Struts 2的拦截器机制
				09、使用Struts 2的Ajax支持
				10、struts2中action的定义及方法调用
				11、模型驱动与属性驱动获取请求参数
				12、struts2中验证框架使用及配置
				13、OGNL表达式
				14、valueStack原理及使用
		02、Spring框架
				01、Spring简介和Spring 4的变化
				02、框架原理介绍
				03、框架环境搭建
				04、IOC思想与DI相关概念
				05、创建Bean的方式及实现原理
				06、Spring父子容器
				07、POJO编程模型
				08、使用Spring MVC构建Web应用程序
				09、使用Spring进行JDBC数据访问
				10、通过Spring使用JPA进行数据访问
				11、使用Spring管理事务
				12、Spring MVC的高级技术
				13、使用NoSQL数据库
				14、Spring Boot简化Spring开发
		03、Hibernate框架
				01、Java应用分层架构及软件模型
				02、ORM思想
				03、hibernate4与JPA关系介绍
				04、PO对象三种状态分析与切换
				05、hibernate4一级缓存分析与测试
				06、Hibernate多表联合查询
				07、理解对象，关系持久化
				08、对象-关系映射基础
				09、通过Hibernate操纵对象
				10、映射集合和实体关联
				11、Hibernate的检索策略与检索方式
				12、事务与并发
				13、Hibernate高级配置
				14、管理Hibernate的缓存
		04、Maven核心技术
				01、Maven简介、安装与配置
				02、坐标和依赖
				03、仓库介绍与使用
				04、生命周期和插件
				05、聚合与继承
				06、Nexus创建私服
				07、使用Maven进行测试
				08、使用Hudson进行持续集成
				09、使用Maven构建Web应用
		05、MyBatis框架
				01、MyBaits入门
				02、基础模块及其生命周期
				03、MyBatis配置介绍
				04、映射器的主要元素及其使用方法
				05、动态SQL
				06、MyBatis的解析和运行原理
				07、插件设计与开发
				08、Spring项目中集成MyBatis
				09、MyBatis的实用场景
		06、高手进阶
				01、Lucene实现全文检索分析
				02、SVN及项目实战
				03、Log4J日志管理
				04、Junit单元测试
				05、Jmeter压力测试
				06、EasyUI技术
第五阶段Java大数据：
		01、Linux基础
				01、Linux安装与配置
				02、系统管理与目录管理
				03、用户与用户组管理
				04、Shell编 程
				05、服务器配置
		02、Hadoop生态体系
				01、Hadoop使用
				02、MapReduce入门
				03、HDFS及其HDFS架构
				04、Hadoop文件I/O详解
				05、MapReduce编程开发
		03、Spark生态体系
				01、Spark程序开发
				02、Spark编程模型
				03、Spark SQL与DataFrame
				04、scala编程介绍
				05、Python编程介绍
				